package protocol;

import client.Client;
import protocol.messages.*;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Created by bozhidar on 08.11.17.
 */
public class ClientProtocol {
    private Method current;
    private Client client;

    public ClientProtocol(Client client) {
        this.client = client;
        this.changeState("serverGreeting", Object.class);
    }

    public void getNextStep(Object msg) throws InvocationTargetException, IllegalAccessException {
        if (msg instanceof ErrorMessage) {
            client.displayMsg(msg);
        } else current.invoke(this, msg);
    }

    /**
     * Gets the greeting from the server.
     *
     * @param msg is the message passed to the state
     */
    private void serverGreeting(Object msg) {
        if (msg instanceof HelloMessage) {
            client.displayMsg(((HelloMessage) msg).getMessage());
            this.changeState("sendLogin");
            this.sendLogin();
        } else {
            client.reply(new WrongMessage());
        }
    }

    /**
     * Sends the login information.
     */
    private void sendLogin() {
        client.reply(client.buildLoginMessage());
        this.changeState("listenForLoginResponse", Object.class);
    }

    /**
     * Listens for login response.
     * If there is a problem with the login data, it will loop back to sending the login information.
     * If it is successful, it will go to the next state, where the post login state will be determined.
     *
     * @param msg is the message passed to the state
     */
    private void listenForLoginResponse(Object msg) {
        if (msg instanceof UserNotRegisteredMessage || msg instanceof WrongPasswordMessage || msg instanceof WrongUserDataMessage) {
            client.displayMsg(((ErrorMessage) msg).getMessage());
            this.changeState("sendLogin");
            this.sendLogin();
        } else if (msg instanceof SuccessLoginMessage) {
            client.displayMsg("You are logged in!\n");
            this.changeState("determinePostLoginState", Object.class);
        } else {
            client.reply(new WrongMessage());
        }
    }

    /**
     * Determines the post login state.
     * It it receives ResultsMessage, the voting has ended and the state continues.
     * If it receives VoteSuccessfulMessage, the user has already voted, but the voting is not over yet.
     * If it receives CandidatesListMessage, the user hasn't voted yet and the voting is not over.
     *
     * @param msg is the message passed to the state
     */
    private void determinePostLoginState(Object msg) throws IOException {
        if (msg instanceof ResultsMessage) {
            this.changeState("displayResults", Object.class);
            this.displayResults(msg);
        } else if (msg instanceof VoteSuccessfulMessage) {
            client.displayMsg(((VoteSuccessfulMessage) msg).getMessage());
            this.changeState("waitForLogOutConfirm", Object.class);
        } else if (msg instanceof CandidatesListMessage) {
            this.changeState("vote", Object.class);
            this.vote(msg);
        } else {
            client.reply(new WrongMessage());
        }
    }

    /**
     * Gets the vote of the user and sends it to the server.
     * If it receives a ElectionCompleteMessage it means that the protocol is at this stage
     * i.e. the user is still voting and the election has finished (the server timer has expired).
     * Then the method will go to determinePostLoginState in order to get the ResultsMessage.
     * Then the VoteMessage generated by the Client is checked - if it is null it means that the
     * user has failed to make input in the time frame of 2 minutes and then the protocol will proceed to
     * logging the user out.
     *
     * @param msg is the message passed to the state
     */
    private void vote(Object msg) throws IOException {
        if (msg instanceof ResultsMessage) {
            this.changeState("displayResults", Object.class);
            this.displayResults(msg);
        } else {
            client.displayMsg("Please vote!\nYou have 2 MINUTES to vote before log out");
            new Thread(() -> {
                VoteMessage vmsg = null;
                try {
                    vmsg = client.vote(((CandidatesListMessage) msg).getNames(), ((CandidatesListMessage) msg).getNonce());
                } catch (IOException e) {
                    e.printStackTrace();
                }
                //If the server hasn't interrupted the voting
                if(client.getTIMEOUT() > 0) {
                    if (vmsg != null) {
                        client.reply(vmsg);
                        this.changeState("loggedGetVoteConfirmation", Object.class);
                    } else {
                        client.displayMsg("\nYou did not vote within 2 minutes! Now you will be logged out!");
                        client.reply(new LogOutMessage());
                        this.changeState("waitForLogOutConfirm", Object.class);
                    }
                }
            }).start();

        }
    }

    /**
     * Checks if the vote has been successful.
     * If it gets a VoteSuccessfulMessage then it proceeds to logging out the user.
     * If it gets WrongVoteInfoMessage goes back to listening for the response of the server.
     *
     * @param msg is the message passed to the state
     */
    private void loggedGetVoteConfirmation(Object msg) {
        if (msg instanceof VoteSuccessfulMessage) {
            client.displayMsg("\n" + ((VoteSuccessfulMessage) msg).getMessage() + "\n");
            this.changeState("waitForLogOutConfirm", Object.class);
        } else if (msg instanceof WrongVoteInfoMessage) {
            client.displayMsg(((WrongVoteInfoMessage) msg).getMessage());
            this.changeState("determinePostLoginState", Object.class);
        } else {
            client.reply(new WrongMessage());
        }
    }

    /**
     * Displays the results and proceeds to the log out state.
     *
     * @param msg is the message passed to the state
     */
    private void displayResults(Object msg) {
        String results = "\nVoting finished!\n\nResults:\n";
        ResultsMessage res = (ResultsMessage) msg;
        for (int i = 0; i < res.getNames().size(); i++) {
            results += (res.getNames().get(i) + " - " + res.getVotes().get(i) + " votes\n");
        }
        client.displayMsg(results);
        //Stops the thread that expects a vote name.
        client.stopReading();
        this.changeState("waitForLogOutConfirm", Object.class);
    }

    /**
     * Upon confirmation from the server it logs out the client.
     *
     * @param msg is the message passed to the state
     */
    private void waitForLogOutConfirm(Object msg) {
        if (msg instanceof LogOutSuccessfulMessage) {
            client.logOut();
            client.displayMsg("Logged out!");
        } else {
            client.reply(new WrongMessage());
        }
    }

    /**
     * Changes the current state.
     *
     * @param next is the name of the next state
     * @param types are the types the method takes
     */
    private void changeState(String next, Class... types) {
        try {
            current = this.getClass().getDeclaredMethod(next, types);
        } catch (NoSuchMethodException e) {
            //Impossible
            e.printStackTrace();
        }
    }

}
